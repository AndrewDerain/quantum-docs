---
title: Quantum computing glossary
description: A glossary of common terms, actions and objects used in quantum computing.
author: QuantumWriter
ms.author: Alan.Geller@microsoft.com 
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.glossary
---

# Quantum computing glossary

|Term|Definition|
|-------------|----------|
|<a id="adjoint"></a>Adjoint|The complex conjugate transpose of an operation. For operations that implement a unitary operator, the adjoint is the inverse of the operation and is indicated by a dagger symbol. For example, if the operation `U` represents the unitary operator $U$, then `Adjoint U` represents $U^\dagger$. For more information, see [Adjoint](xref:microsoft.quantum.language.file-structure#adjoint).|
|<a id="ancilla"></a>Ancilla|A qubit that serves as temporary memory for a quantum computer and is allocated and de-allocated as needed.  For more information, see [Multiple qubits](xref:microsoft.quantum.concepts.multiple-qubits).|
|<a id="bell-state"></a>Bell state|One of four specific maximally entangled quantum states of two qubits. The four states are defined $\ket{\beta_{ij}} = (\mathbb{I} \otimes X^iZ^j) (\ket{00} + \ket{11}) / \sqrt{2}$. A Bell state is also known as an [EPR pair](xref:microsoft.quantum.glossary#epr).|
|<a id="bloch"></a>Bloch sphere|A graphical representation of a single-qubit quantum state as a three-dimensional real-valued vector. For more information, see  [Visualizing Qubits and Transformations using the Bloch Sphere](xref:microsoft.quantum.concepts.qubit#visualizing-qubits-and-transformations-using-the-bloch-sphere).|
|<a id="callable"></a>Callable|An operation or function in the Q# language. For more information, see [Operation and function types](xref:microsoft.quantum.language.type-model#operation-and-function-types).|
|<a id="clifford"></a>Clifford group|The set of operations that occupy the octants of the Bloch sphere and effect permutations of the Pauli operators. These include the operations [$X$](xref:microsoft.quantum.intrinsic.x), [$Y$](xref:microsoft.quantum.intrinsic.y), [$Z$](xref:microsoft.quantum.intrinsic.z), [$H$](xref:microsoft.quantum.intrinsic.h) and [$S$](xref:microsoft.quantum.intrinsic.s).|
|<a id="controlled"></a>Controlled|A quantum operation that takes one or more qubits as enablers for the target operation. For more information, see [Controlled](xref:microsoft.quantum.language.type-model#controlled).|
|<a id="dirac"></a>Dirac Notation|A shorthand representation of quantum states, for example $\ket{+} = H \ket{0} = \frac{1}{\sqrt{2}} \left(\ket{0} + \ket{1} \right) = \frac{1}{\sqrt{2}}\begin{bmatrix} 1 \\\\  1 \end{bmatrix}$. For more information, see [Dirac Notation](xref:microsoft.quantum.concepts.dirac).|
|<a id="eigenvalue"></a>Eigenvalue|The factor by which the magnitude of an [eigenvector](xref:microsoft.quantum.glossary#eigenvector) of a given transformation is changed by the application of the transformation. An eigenvalue can be a complex number of any argument. For more information, see [Advanced matrix concepts](xref:microsoft.quantum.concepts.matrix-advanced).|
|<a id="eigenvector"></a>Eigenvector|A vector whose direction is unchanged by a given transformation and whose magnitude is changed by a factor corresponding to that vector's [eigenvalue](xref:microsoft.quantum.glossary#eigenvalue). An eigenvector can be a complex number of any argument. For more information, see [Advanced matrix concepts](xref:microsoft.quantum.concepts.matrix-advanced).|
|<a id="entanglement"></a>Entanglement|Quantum particles, such as qubits, can be connected or *entangled* such that actions performed on one immediately duplicate on the other. Entanglement is essential to measuring the state of a qubit.  For more information, see [Advanced matrix concepts](xref:microsoft.quantum.concepts.matrix-advanced).|
|<a id="epr"></a>EPR pair|One of four specific maximally entangled quantum states of two qubits. The four states are defined $\ket{\beta_{ij}} = (\mathbb{1} \otimes X^iZ^j) (\ket{00} + \ket{11}) / \sqrt{2}$. An EPR pair is also known as a [Bell state](xref:microsoft.quantum.glossary#bell-state)|
|<a id="evolution"></a>Evolution|How a quantum state changes over time. For more information, see [Matrix exponentials](xref:microsoft.quantum.concepts.matrix-advanced#matrix-exponentials).|
|<a id="function"></a>Function|A type of subroutine in the Q# language that is purely classical (non-quantum). While functions are used within quantum algorithms, they may not act on qubits or call operations. For more information, see [Operation and function types](xref:microsoft.quantum.language.type-model#operation-and-function-types).|
|<a id="hadamard"></a>Hadamard|The Hadamard operation (also referred to as the Hadamard gate or transform) acts on a single qubit and puts it in superposition. In Q#, it is the pre-defined [$H$](xref:microsoft.quantum.intrinsic.h) operation.|
|<a id="gate"></a>Gate|A legacy term for a quantum operation, based on the concept of classical logic gates.|
|<a id="global-phase"></a>Global phase|When two states are identical up to a multiple of a complex number $e^{i\phi}$, they are said to differ up to a global phase. Unlike local phases, global phases cannot be observed through any measurement. For more information, see [The Qubit](xref:microsoft.quantum.concepts.qubit).|
|<a id="immutable"></a>Immutable|A variable whose value cannot be changed. An immutable is created using the `let` keyword. To declare variables that *can* be changed, use the [mutable](xref:microsoft.quantum.glossary#immutable) keyword to declare and the `set` keyword to modify the value. |
|<a id="measurement"></a>Measurement|Obtaining a classical bit from a qubit (or set of qubits). For more information, see [The Qubit](xref:microsoft.quantum.concepts.qubit#measuring-a-qubit).|
|<a id="mutable"></a>Mutable|A variable whose value may be changed after it is created. A mutable is declared using the `mutable` keyword and modified using the `set` keyword. Variables created with the `let` keyword are [immutable](xref:microsoft.quantum.glossary#immutable) and their value cannot be changed.|
|<a id="namespace"></a>Namespace|A label for a collection of related names (i.e., operations, functions, and user-defined types). For instance the namespace [Microsoft.Quantum.Preparation](xref:microsoft.quantum.preparation) labels all of the symbols defined in the standard library that help with preparing initial states.|
|<a id="operation"></a>Operation|The basic unit of quantum execution in Q#. It is roughly equivalent to a function in C, C++ or Python, or a static method in C# or Java. For more information, see [Operation and function types](xref:microsoft.quantum.language.type-model#operation-and-function-types).|
|<a id="operator-application"></a>Operator application|Performing a quantum operation. This typically applies a unitary matrix to the current quantum   state vector.|
|<a id="oracle"></a>Oracle|A subroutine that provides data-dependent information to a quantum algorithm at runtime. Typically, the goal is to provide a superposition of outputs corresponding to inputs that are in superposition. For more information, see [Oracles](xref:microsoft.quantum.libraries.data-structures#oracles).|
|<a id="partial-app"></a>Partial application|Calling a function or operation without all the required inputs. This returns a new callable that only needs the missing parameters (indicated by an underscore) to be supplied during a future application. For example, given the function `MyFunc(x : int, y : int) : int {return x + y;}` you can partially apply it to a new function `let NewFunc = MyFunc(_, 3)`. You can then call the new function at a later time with the missing parameter `NewFunc(2)` which returns the value *5*.  For more information, see [Partial application](xref:microsoft.quantum.language.expressions#partial-application).|
|<a id="pauli"></a>Pauli operators|A set of three 2 x 2 unitary matrices known as the `X`, `Y` and `Z` quantum operations. The identity matrix, $I$, is often included in the set as well.  $I = \begin{bmatrix} 1 & 0 \\\\ 0 & 1 \end{bmatrix}$, $X = \begin{bmatrix} 0 & 1 \\\\ 1 & 0 \end{bmatrix}$, $Y = \begin{bmatrix} 0 & -i \\\\ i & 0 \end{bmatrix}$, $Z = \begin{bmatrix} 1 & 0 \\\\ 0 & -1 \end{bmatrix}$.   For more information, see [Single-qubit operations](xref:microsoft.quantum.concepts.qubit#single-qubit-operations).|
|<a id="circuit"></a>Quantum circuit diagram|A method to graphically represent the sequence of operations for simple quantum programs. For more information, see [Quantum circuits](xref:microsoft.quantum.concepts.circuits).|
|<a id="quantum-libraries"></a>Quantum libraries|Collections of operations, functions and user-defined types for creating Q# programs. The [Standard library](xref:microsoft.quantum.libraries.standard.intro) is installed by default. Other libraries available are the [Chemistry library](xref:microsoft.quantum.chemistry.concepts.intro), the [Numerics library](xref:microsoft.quantum.numerics.intro) and the [Machine learning library](xref:mmicrosoft.quantum.machine-learning.concepts.intro).|
|<a id="quantum-state"></a>Quantum state|In quantum computing, the information about a qubit that can be physically measured. The quantum simulator uses this information to simulate how a qubit responds to operations. For more information, see [The Qubit](xref:microsoft.quantum.concepts.qubit).|
|<a id="qubit"></a>Qubit|A basic unit of quantum storage. For more information, see [The Qubit](xref:microsoft.quantum.concepts.qubit).|
|<a id="rus"></a>Repeat-until-success|A quantum algorithm that probabilistically succeeds. Upon failure, the routine will retry until successful (or a limit has been reached). For more information, see [Repeat Until Success (RUS)](xref:microsoft.quantum.techniques.qubits#measurements)|
|<a id="standard"></a>Standard libraries|Operations, functions and user-defined types that are installed along with the Q# compiler during installation. The standard library implementation is agnostic with respect to target machines. For more information, see [Standard libraries](xref:microsoft.quantum.libraries.standard.intro).|
|<a id="superposition"></a>Superposition|The concept in quantum computing that a qubit can hold two states at once, for example $\ket{\0}$ and $\ket{\1}$, until it is measured.  For more information, see [What is quantum computing](xref:microsoft.quantum.overview.what).|
|<a id="target"></a>Target machine|A compilation target that lowers an abstract quantum program towards hardware or simulation. This typically include re-writes for many purposes including gate replacement, encoding for error correction, geometric layout and others. For more information, see [Quantum simulators and host applications](xref:microsoft.quantum.machines).|
|<a id="teleporation"></a>Teleportation|A method for moving data, or the [quantum state](xref:microsoft.quantum.glossary#quantum-state), of one qubit to another using [entanglement](xref:microsoft.quantum.glossary#entanglement) and [measurement](xref:microsoft.quantum.glossary#measurement).  For more information, see [Quantum circuits](xref:microsoft.quantum.concepts.circuits) and [Putting it all together](xref:microsoft.quantum.techniques.puttingittogether).|
|<a id="tuple"></a>Tuple|A collection of comma-separated values that acts as a single value. The *type* of a tuple is defined by the types of values it contains. In Q#, tuples are immutable and can be nested, contain arrays, or used in an array. For more information, see [Tuple types](xref:microsoft.quantum.language.type-model#tuple-types).|
|<a id="unitary"></a>Unitary operator|An operator whose inverse is equal to its [adjoint](xref:microsoft.quantum.glossary#adjoint), i.e., $UU^{\dagger} = \id$.|
|<a id="user-def"></a>User-defined type|A collection of built-in or previously defined types that may be referred to as a single unit. For more information, see [User-defined types](xref:microsoft.quantum.language.type-model#user-defined-types).|

